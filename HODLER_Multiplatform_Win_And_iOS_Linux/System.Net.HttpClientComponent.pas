{*******************************************************}
{                                                       }
{           CodeGear Delphi Runtime Library             }
{ Copyright(c) 2014-2017 Embarcadero Technologies, Inc. }
{              All rights reserved                      }
{                                                       }
{*******************************************************}

unit System.Net.HttpClientComponent;

interface

{$IFDEF MSWINDOWS}
{$HPPEMIT '#pragma comment(lib, "winhttp")'}
{$HPPEMIT '#pragma comment(lib, "crypt32")'}
{$ENDIF}

{$SCOPEDENUMS ON}

uses
  System.Sysutils, System.Classes, System.Generics.Collections, System.Types,
  System.Net.URLClient, System.Net.HttpClient, System.Net.Mime;

type
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  ///  <summary> Request completion Event signature</summary>
  ///  <param name="Sender"> HTTPClientComponent that invoked the Event</param>
  ///  <param name="AResponse">Response generated by the request</param>
  TRequestCompletedEvent = procedure(const Sender: TObject; const AResponse: IHTTPResponse) of object;
  ///  <summary> Request error Event signature</summary>
  ///  <param name="Sender"> HTTPClientComponent that invoked the Event</param>
  ///  <param name="AError">Error generated by the request</param>
  TRequestErrorEvent = procedure(const Sender: TObject; const AError: string) of object;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to Manage an HTTPClient</summary>
  TNetHTTPClient = class(TComponent)
  private
    FHttpClient: THTTPClient;
    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnReceiveData: TReceiveDataEvent;
    FAsynchronous: Boolean;

    procedure DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AError: string);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var Abort: Boolean);

    procedure DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);

    function GetMaxRedirects: Integer;
    procedure SetMaxRedirects(const Value: Integer);
    procedure SetAuthEvent(const Value: TCredentialsStorage.TCredentialAuthevent);
    procedure SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
    procedure SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
    function GetAuthEvent: TCredentialsStorage.TCredentialAuthevent;
    function GetOnNeedClientCertificate: TNeedClientCertificateEvent;
    function GetOnValidateServerCertificate: TValidateCertificateEvent;
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    function GetAllowCookies: Boolean;
    procedure SetAllowCookies(const Value: Boolean);
    function GetCookieManager: TCookieManager;
    procedure SetCookieManager(const Value: TCookieManager);
    function GetHandleRedirects: Boolean;
    procedure SetHandleRedirects(const Value: Boolean);
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    function GetContentType: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    procedure SetContentType(const Value: string);
    function GetCredentialsStorage: TCredentialsStorage;
    procedure SetCredentialsStorage(const Value: TCredentialsStorage);
    function GetUserAgent: string;
    procedure SetUserAgent(const Value: string);
    function GetConnectionTimeout: Integer;
    function GetResponseTimeout: Integer;
    procedure SetConnectionTimeout(const Value: Integer);
    procedure SetResponseTimeout(const Value: Integer);

  public
    /// <summary> Initializes the HTTPComponent </summary>
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>Send 'PUT' command to url</summary>
    function Put(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send a special 'MERGE' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function MergeAlternative(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Send a special 'PATCH' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;


    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <param name="ARequest">The request that is going to be Executed</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interfaced object and
    /// It's released automatically.</returns>
    function Execute(const ARequest: IHTTPRequest; const AContentStream: TStream = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURI">The URI that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURI: TURI; const ASourceStream: TStream = nil;
      const AContentStream: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURIStr">The URI string that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURIStr: string; const ASourceStream: TStream = nil;
      const AContentStream: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload; inline;

    /// <summary> Cookie manager object to be used by the client.</summary>
    property CookieManager: TCookieManager read GetCookieManager write SetCookieManager;
    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string read GetCustomHeaderValue write SetCustomHeaderValue;

    /// <summary> Credentials Storage to be used by the client</summary>
    property CredentialsStorage: TCredentialsStorage read GetCredentialsStorage write SetCredentialsStorage;

    /// <summary> Proxy Settings to be used by the client.</summary>
    property ProxySettings: TProxySettings read GetProxySettings write SetProxySettings;

  published
    /// <summary>Property to indicate if the requests are going to be Synchronous or Asynchronous</summary>
    property Asynchronous: Boolean read FAsynchronous write FAsynchronous;

    /// <summary> Property to set the ConnectionTimeout</summary>
    property ConnectionTimeout: Integer read GetConnectionTimeout write SetConnectionTimeout;
    /// <summary> Property to set the ResponseTimeout</summary>
    property ResponseTimeout: Integer read GetResponseTimeout write SetResponseTimeout;

    /// <summary> Cookies policy to be used by the client.</summary>
    /// <remarks>If false the cookies from server will not be accepted,
    /// but the cookies in the cookie manager will be sent.</remarks>
    property AllowCookies: Boolean read GetAllowCookies write SetAllowCookies;
    /// <summary> Redirection policy to be used by the client.</summary>
    property HandleRedirects: Boolean read GetHandleRedirects write SetHandleRedirects;
    /// <summary> Maximum number of redirects</summary>
    property MaxRedirects: Integer read GetMaxRedirects write SetMaxRedirects default 5;

    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage write SetAcceptLanguage;
    /// <summary>Property to manage the 'Content-Type' header</summary>
    property ContentType: string read GetContentType write SetContentType;
    /// <summary> Property to set the UserAgent sent with the request </summary>
    property UserAgent: string read GetUserAgent write SetUserAgent;

    /// <summary> Event fired when a ClientCertificate is needed</summary>
    property OnNeedClientCertificate: TNeedClientCertificateEvent read GetOnNeedClientCertificate write SetOnNeedClientCertificate;
    /// <summary> Event fired when checking the validity of a Server Certificate</summary>
    property OnValidateServerCertificate: TValidateCertificateEvent read GetOnValidateServerCertificate write SetOnValidateServerCertificate;

    /// <summary> UserName needed to be authenticated to the proxy</summary>
    property OnAuthEvent: TCredentialsStorage.TCredentialAuthevent read GetAuthEvent write SetAuthEvent;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError write FOnRequestError;

    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read FOnReceiveData write FOnReceiveData;
  end;

                                                                                             
  TNetHTTPClientHelper = class helper for TNetHTTPClient
  private
    function GetRedirectsWithGET: THTTPRedirectsWithGET;
    function GetSecureProtocols: THTTPSecureProtocols;
    procedure SetRedirectsWithGET(const AValue: THTTPRedirectsWithGET);
    procedure SetSecureProtocols(const AValue: THTTPSecureProtocols);
  public
    property RedirectsWithGET: THTTPRedirectsWithGET read GetRedirectsWithGET write SetRedirectsWithGET default CHTTPDefRedirectsWithGET;
    property SecureProtocols: THTTPSecureProtocols read GetSecureProtocols write SetSecureProtocols default CHTTPDefSecureProtocols;
  end;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to handle HTTP Requests</summary>
  TNetHTTPRequest = class(TComponent)
  private
    FClient: TNetHTTPClient;

    FContentStream: TStream;
    FSourceStream: TStream;

    FURL: string;
    FMethodString: string;

    FHttpRequest: IHTTPRequest;
    FHttpResponse: IHTTPResponse;

    FOnNeedClientCertificate: TNeedClientCertificateEvent;
    FOnValidateServerCertificate: TValidateCertificateEvent;
    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnReceiveData: TReceiveDataEvent;
    FCustomHeaders: TNetHeaders;
    FAsynchronous: Boolean;
    FConnectionTimeout: Integer;
    FResponseTimeout: Integer;

    procedure DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AError: string);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength: Int64; AReadCount: Int64; var Abort: Boolean);

    procedure DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);

    function GetMethodString: string;
    procedure SetMethodString(const Value: string);

    function GetURL: string;
    procedure SetURL(const Value: string);

    function GetClient: TNetHTTPClient;
    procedure SetClient(const Value: TNetHTTPClient);
    procedure SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
    procedure SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
    function GetOnReceiveData: TReceiveDataEvent;
    procedure SetOnReceiveData(const Value: TReceiveDataEvent);

    function GetRequest(const AMethod: string; const AURL: string; const ASourceStream: TStream;
      AOwnsSourceStream: Boolean = False): IHTTPRequest;
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);

  protected
    /// <summary> Notification method to process component adding or removal from a form/datamodule</summary>
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function DoExecute(const ARequest: IHTTPRequest; const AResponseContent: TStream; const AHeaders: TNetHeaders;
      AOwnsSourceStream: Boolean = False): IHTTPResponse;

  public
    constructor Create(AOwner: TComponent); override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string; AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>Send 'PUT' command to url</summary>
    function Put(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'MERGE' command to url</summary>
    function MergeAlternative(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function Execute(const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string read GetCustomHeaderValue write SetCustomHeaderValue;
    /// <summary> Content stream associated with the request component</summary>
    property ContentStream: TStream read FContentStream write FContentStream;
    /// <summary> Source stream associated with the request component</summary>
    property SourceStream: TStream read FSourceStream write FSourceStream;

  published
    /// <summary>Property to indicate if the requests are going to be Synchronous or Asynchronous</summary>
    property Asynchronous: Boolean read FAsynchronous write FAsynchronous;

    /// <summary> Property to set/get the ConnectionTimeout. Value is in milliseconds</summary>
    property ConnectionTimeout: Integer read FConnectionTimeout write FConnectionTimeout;
    /// <summary> Property to set/get the ResponseTimeout. Value is in milliseconds</summary>
    property ResponseTimeout: Integer read FResponseTimeout write FResponseTimeout;

    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage write SetAcceptLanguage;

    /// <summary> Property to access the MethodString from the request</summary>
    property MethodString: string read GetMethodString write SetMethodString;
    /// <summary> URL to be accessed</summary>
    property URL: string read GetURL write SetURL;
    /// <summary> Client component associated with the request component</summary>
    property Client: TNetHTTPClient read GetClient write SetClient;

    /// <summary> Event fired when a ClientCertificate is needed</summary>
    property OnNeedClientCertificate: TNeedClientCertificateEvent read FOnNeedClientCertificate write SetOnNeedClientCertificate;
    /// <summary> Event fired when checking the validity of a Server Certificate</summary>
    property OnValidateServerCertificate: TValidateCertificateEvent read FOnValidateServerCertificate write SetOnValidateServerCertificate;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError write FOnRequestError;

    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read GetOnReceiveData write SetOnReceiveData;
  end;
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

implementation

uses
  System.NetEncoding,
  System.NetConsts;



{ TNetHTTPClient }

constructor TNetHTTPClient.Create(AOwner: TComponent);
begin
  inherited;
  FHttpClient := THTTPClient.Create;
  FHttpClient.OnReceiveData := DoOnReceiveData;
end;

destructor TNetHTTPClient.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

function TNetHTTPClient.Delete(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginDelete(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Delete(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

procedure TNetHTTPClient.DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);
begin
  try
    DoOnRequestCompleted(Self, THTTPClient.EndAsyncHTTP(AAsyncResult));
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

procedure TNetHTTPClient.DoOnReceiveData(const Sender: TObject; AContentLength, AReadCount: Int64; var Abort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnReceiveData) then
  begin
    LAbort := Abort;
    TThread.Synchronize(nil, procedure
    begin
      FOnReceiveData(Sender, AContentLength, AReadCount, LAbort);
    end);
    Abort := LAbort;
  end;
end;

procedure TNetHTTPClient.DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
begin
  if Assigned(FOnRequestCompleted) then
    TThread.Synchronize(nil, procedure
    begin
      FOnRequestCompleted(Sender, AResponse);
    end);
end;

procedure TNetHTTPClient.DoOnRequestError(const Sender: TObject; const AError: string);
begin
  if Assigned(FOnRequestError) then
    TThread.Synchronize(nil, procedure
    begin
      FOnRequestError(Sender, AError);
    end)
  else
    raise ENetHTTPClientException.Create(AError);
end;

function TNetHTTPClient.Execute(const ARequestMethod: string; const AURI: TURI; const ASourceStream,
  AContentStream: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := IHTTPResponse(FHttpClient.BeginExecute(DoOnAsyncRequestCompleted, ARequestMethod, AURI, ASourceStream,
        AContentStream, AHeaders))
    else
    begin
      Result := IHTTPResponse(FHttpClient.Execute(ARequestMethod, AURI, ASourceStream, AContentStream, AHeaders));
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Execute(const ARequestMethod, AURIStr: string; const ASourceStream, AContentStream: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  Result := Execute(ARequestMethod, TURI.Create(AURIStr), ASourceStream, AContentStream, AHeaders);
end;

function TNetHTTPClient.Execute(const ARequest: IHTTPRequest; const AContentStream: TStream): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginExecute(DoOnAsyncRequestCompleted, ARequest, AContentStream) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Execute(ARequest, AContentStream);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Get(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginGet(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Get(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.GetAccept: string;
begin
  Result := FHttpClient.Accept;
end;

function TNetHTTPClient.GetAcceptCharSet: string;
begin
  Result := FHttpClient.AcceptCharSet;
end;

function TNetHTTPClient.GetAcceptEncoding: string;
begin
  Result := FHttpClient.AcceptEncoding;
end;

function TNetHTTPClient.GetAcceptLanguage: string;
begin
  Result := FHttpClient.AcceptLanguage;
end;

function TNetHTTPClient.GetAllowCookies: Boolean;
begin
  Result := FHttpClient.AllowCookies;
end;

function TNetHTTPClient.GetAuthEvent: TCredentialsStorage.TCredentialAuthevent;
begin
  Result := FHttpClient.AuthEvent;
end;

function TNetHTTPClient.GetConnectionTimeout: Integer;
begin
  Result := FHttpClient.ConnectionTimeout;
end;

function TNetHTTPClient.GetContentType: string;
begin
  Result := FHttpClient.ContentType;
end;

function TNetHTTPClient.GetCookieManager: TCookieManager;
begin
  Result := FHttpClient.CookieManager;
end;

function TNetHTTPClient.GetCustomHeaderValue(const AName: string): string;
begin
  Result := FHttpClient.CustomHeaders[AName];
end;

function TNetHTTPClient.GetHandleRedirects: Boolean;
begin
  Result := FHttpClient.HandleRedirects;
end;

function TNetHTTPClient.GetCredentialsStorage: TCredentialsStorage;
begin
  Result := FHttpClient.CredentialsStorage;
end;

function TNetHTTPClient.GetMaxRedirects: Integer;
begin
  Result := FHttpClient.MaxRedirects;
end;

function TNetHTTPClient.GetOnNeedClientCertificate: TNeedClientCertificateEvent;
begin
  Result := FHttpClient.OnNeedClientCertificate;
end;

function TNetHTTPClient.GetOnValidateServerCertificate: TValidateCertificateEvent;
begin
  Result := FHttpClient.OnValidateServerCertificate;
end;

function TNetHTTPClient.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function TNetHTTPClient.GetRange(const AURL: string; AStart, AnEnd: Int64; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginGetRange(DoOnAsyncRequestCompleted, AURL, AStart, AnEnd, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.GetRange(AURL, AStart, AnEnd, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.GetResponseTimeout: Integer;
begin
  Result := FHttpClient.ResponseTimeout;
end;

function TNetHTTPClient.GetUserAgent: string;
begin
  Result := FHttpClient.UserAgent;
end;

function TNetHTTPClient.Head(const AURL: string; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginHead(DoOnAsyncRequestCompleted, AURL, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Head(AURL, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Merge(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginMerge(DoOnAsyncRequestCompleted, AURL, ASource, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Merge(AURL, ASource, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.MergeAlternative(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginMergeAlternative(DoOnAsyncRequestCompleted, AURL, ASource, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.MergeAlternative(AURL, ASource, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Options(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginOptions(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Options(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Patch(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPatch(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Patch(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.PatchAlternative(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPatchAlternative(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.PatchAlternative(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource: TStrings; const AResponseContent: TStream;
  const AEncoding: TEncoding; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AEncoding, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AEncoding, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Post(const AURL, ASourceFile: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASourceFile, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASourceFile, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

function TNetHTTPClient.Put(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPut(DoOnAsyncRequestCompleted, AURL, ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Put(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

procedure TNetHTTPClient.SetAccept(const Value: string);
begin
  FHttpClient.Accept := Value;
end;

procedure TNetHTTPClient.SetAcceptCharSet(const Value: string);
begin
  FHttpClient.AcceptCharSet := Value;
end;

procedure TNetHTTPClient.SetAcceptEncoding(const Value: string);
begin
  FHttpClient.AcceptEncoding := Value;
end;

procedure TNetHTTPClient.SetAcceptLanguage(const Value: string);
begin
  FHttpClient.AcceptLanguage := Value;
end;

procedure TNetHTTPClient.SetAllowCookies(const Value: Boolean);
begin
  FHttpClient.AllowCookies := Value;
end;

procedure TNetHTTPClient.SetAuthEvent(const Value: TCredentialsStorage.TCredentialAuthevent);
begin
  FHttpClient.AuthEvent := Value;
end;

procedure TNetHTTPClient.SetConnectionTimeout(const Value: Integer);
begin
  FHttpClient.ConnectionTimeout := Value;
end;

procedure TNetHTTPClient.SetContentType(const Value: string);
begin
  FHttpClient.ContentType := Value;
end;

procedure TNetHTTPClient.SetCookieManager(const Value: TCookieManager);
begin
  FHttpClient.CookieManager := Value;
end;

procedure TNetHTTPClient.SetCredentialsStorage(const Value: TCredentialsStorage);
begin
  FHttpClient.CredentialsStorage := Value;
end;

procedure TNetHTTPClient.SetCustomHeaderValue(const AName, Value: string);
begin
  FHttpClient.CustomHeaders[AName] := Value;
end;

procedure TNetHTTPClient.SetHandleRedirects(const Value: Boolean);
begin
  FHttpClient.HandleRedirects := Value;
end;

procedure TNetHTTPClient.SetMaxRedirects(const Value: Integer);
begin
  FHttpClient.MaxRedirects := Value;
end;

procedure TNetHTTPClient.SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
begin
  FHttpClient.OnNeedClientCertificate := Value;
end;

procedure TNetHTTPClient.SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
begin
  FHttpClient.OnValidateServerCertificate := Value;
end;

procedure TNetHTTPClient.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure TNetHTTPClient.SetResponseTimeout(const Value: Integer);
begin
  FHttpClient.ResponseTimeout := Value;
end;

procedure TNetHTTPClient.SetUserAgent(const Value: string);
begin
  FHttpClient.UserAgent := Value;
end;

function TNetHTTPClient.Trace(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginTrace(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Trace(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

{ TNetHTTPClientHelper }

function TNetHTTPClientHelper.GetRedirectsWithGET: THTTPRedirectsWithGET;
begin
  Result := FHttpClient.RedirectsWithGET;
end;

function TNetHTTPClientHelper.GetSecureProtocols: THTTPSecureProtocols;
begin
  Result := FHttpClient.SecureProtocols;
end;

procedure TNetHTTPClientHelper.SetRedirectsWithGET(const AValue: THTTPRedirectsWithGET);
begin
  FHttpClient.RedirectsWithGET := AValue;
end;

procedure TNetHTTPClientHelper.SetSecureProtocols(const AValue: THTTPSecureProtocols);
begin
  FHttpClient.SecureProtocols := AValue;
end;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

{ TNetHTTPRequest }

constructor TNetHTTPRequest.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TNetHTTPRequest.DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);
begin
  try
    FHttpResponse := THTTPClient.EndAsyncHTTP(AAsyncResult);
    DoOnRequestCompleted(Self, FHttpResponse);
  except
    on E: Exception do
      DoOnRequestError(Self, E.Message);
  end;
end;

procedure TNetHTTPRequest.DoOnReceiveData(const Sender: TObject; AContentLength, AReadCount: Int64; var Abort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnReceiveData) then
  begin
    LAbort := Abort;
    TThread.Synchronize(nil, procedure
    begin
      FOnReceiveData(Sender, AContentLength, AReadCount, LAbort);
    end);
    Abort := LAbort;
  end
  else
    FClient.DoOnReceiveData(Self, AContentLength, AReadCount, Abort);
end;

procedure TNetHTTPRequest.DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
begin
  if Assigned(FOnRequestCompleted) then
    TThread.Synchronize(nil, procedure
    begin
      FOnRequestCompleted(Sender, AResponse);
    end)
  else
    FClient.DoOnRequestCompleted(Self, AResponse);
end;

procedure TNetHTTPRequest.DoOnRequestError(const Sender: TObject; const AError: string);
begin
  if Assigned(FOnRequestError) then
    TThread.Synchronize(nil, procedure
    begin
      FOnRequestError(Sender, AError);
    end)
  else
    FClient.DoOnRequestError(Self, AError);
end;

function TNetHTTPRequest.Delete(const AURL: string; const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodDelete, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Execute(const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(FMethodString, FURL, nil);
  Result := DoExecute(FHttpRequest, FContentStream, AHeaders);
end;

type
  TDummyHTTPClient = class(THTTPClient);

function TNetHTTPRequest.DoExecute(const ARequest: IHTTPRequest; const AResponseContent: TStream;
  const AHeaders: TNetHeaders; AOwnsSourceStream: Boolean): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  Result := nil;
  FHttpResponse := nil;
  if ARequest <> nil then
  begin
    try
      LHeaders := FCustomHeaders + AHeaders;
      if FAsynchronous then
      begin
        if AOwnsSourceStream then
          Result := TDummyHTTPClient(FClient.FHttpClient).InternalExecuteAsync(nil, DoOnAsyncRequestCompleted, ARequest,
            AResponseContent, LHeaders, AOwnsSourceStream) as IHTTPResponse
        else
          Result := FClient.FHttpClient.BeginExecute(DoOnAsyncRequestCompleted, ARequest, AResponseContent, LHeaders) as IHTTPResponse;
      end
      else
      begin
        Result := FClient.FHttpClient.Execute(ARequest, AResponseContent, LHeaders);
        DoOnRequestCompleted(Self, Result);
      end;
      FHttpResponse := Result;
    except
      on E: Exception do
        DoOnRequestError(Self, E.Message);
    end;
  end;
end;

function TNetHTTPRequest.Get(const AURL: string; const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodGet, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.GetAccept: string;
begin
  Result := CustomHeaders[sAccept];
end;

function TNetHTTPRequest.GetAcceptCharSet: string;
begin
  Result := CustomHeaders[sAcceptCharSet];
end;

function TNetHTTPRequest.GetAcceptEncoding: string;
begin
  Result := CustomHeaders[sAcceptEncoding];
end;

function TNetHTTPRequest.GetAcceptLanguage: string;
begin
  Result := CustomHeaders[sAcceptLanguage];
end;

function TNetHTTPRequest.GetClient: TNetHTTPClient;
begin
  Result := FClient;
end;

function TNetHTTPRequest.GetCustomHeaderValue(const AName: string): string;
var
  I, Max: Integer;
begin
  Result := '';
  I := 0;
  Max := Length(FCustomHeaders);
  while I < Max do
  begin
    if string.CompareText(FCustomHeaders[I].Name, AName) = 0 then
    begin
      Result := FCustomHeaders[I].Value;
      Break;
    end;
    Inc(I);
  end;
end;

function TNetHTTPRequest.GetMethodString: string;
begin
  Result := FMethodString;
end;

function TNetHTTPRequest.GetOnReceiveData: TReceiveDataEvent;
begin
  Result := FOnReceiveData;
end;

function TNetHTTPRequest.GetRange(const AURL: string; AStart, AnEnd: Int64; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
  LRange: string;
begin
  LRange := 'bytes=';
  if AStart > -1 then
    LRange := LRange + AStart.ToString;
  LRange := LRange + '-';
  if AnEnd > -1 then
    LRange := LRange + AnEnd.ToString;
  LHeaders := AHeaders + [TNetHeader.Create('Range', LRange)]; // do not translate
  Result := Get(AURL, AResponseContent, LHeaders);
end;

function TNetHTTPRequest.GetRequest(const AMethod, AURL: string; const ASourceStream: TStream; AOwnsSourceStream: Boolean): IHTTPRequest;
var
  LRequest: THTTPRequest;
begin
  if FClient = nil then
    raise ENetHTTPRequestException.CreateRes(@SNetHttpComponentRequestClient);
  try
    Result := nil;
    Result := FClient.FHttpClient.GetRequest(AMethod, AURL);
    LRequest := Result as THTTPRequest;
    LRequest.ConnectionTimeout := FConnectionTimeout;
    LRequest.ResponseTimeout := FResponseTimeout;
    Result.OnReceiveData := DoOnReceiveData;
    if ASourceStream = nil then
      Result.SourceStream := FSourceStream
    else
      Result.SourceStream := ASourceStream;
  except
    on E: Exception do
    begin
	  {$IFNDEF AUTOREFCOUNT}
      if AOwnsSourceStream then
        ASourceStream.Free;
	  {$ENDIF AUTOREFCOUNT}
      DoOnRequestError(Self, E.Message);
    end;
  end;
end;

function TNetHTTPRequest.GetURL: string;
begin
  Result := FURL;
end;

function TNetHTTPRequest.Head(const AURL: string; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodHead, AURL, nil);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TNetHTTPRequest.Merge(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodMerge, AURL, ASource);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TNetHTTPRequest.MergeAlternative(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch), TNetHeader.Create('PATCHTYPE', sHTTPMethodMerge)] + AHeaders; // Do not translate
  Result := DoExecute(FHttpRequest, nil, LHeaders);
end;

procedure TNetHTTPRequest.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (AComponent = FClient) and (Operation = opRemove) then
    SetClient(nil);
end;

function TNetHTTPRequest.Options(const AURL: string; const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodOptions, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Patch(const AURL: string; const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPatch, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.PatchAlternative(const AURL: string; const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch)] + AHeaders;
  Result := DoExecute(FHttpRequest, AResponseContent, LHeaders);
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource: TStrings;
  const AResponseContent: TStream; const AEncoding: TEncoding; const AHeaders: TNetHeaders): IHTTPResponse;
var
  I, Pos: Integer;
  LSourceStream: TStringStream;
  LParams: string;
  LHeaders: TNetHeaders;
  LEncoding: TEncoding;
begin
  LParams := '';
  for I := 0 to ASource.Count - 1 do
  begin
    Pos := ASource[I].IndexOf('=');
    if Pos > 0 then
      LParams := LParams + TNetEncoding.URL.EncodeForm(ASource[I].Substring(0, Pos)) + '=' + TNetEncoding.URL.EncodeForm(ASource[I].Substring(Pos + 1)) + '&';
  end;
  if (LParams <> '') and (LParams[High(LParams)] = '&') then
    LParams := LParams.Substring(0, LParams.Length - 1); // Remove last &

  if AEncoding = nil then
    LEncoding := TEncoding.UTF8
  else
    LEncoding := AEncoding;
  LSourceStream := TStringStream.Create(LParams, LEncoding, False);
  try
    FHttpRequest := GetRequest(sHTTPMethodPost, AURL, LSourceStream, FAsynchronous);
    LHeaders := [TNetHeader.Create(sContentType, 'application/x-www-form-urlencoded; charset=urf-8')] + AHeaders;  // do not translate
    Result := DoExecute(FHttpRequest, AResponseContent, LHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource: TMultipartFormData;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource.Stream);
  if FHttpRequest <> nil then
  begin
    FHttpRequest.SourceStream.Position := 0;
    FHttpRequest.AddHeader(sContentType, ASource.MimeTypeHeader);
  end;
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Post(const AURL, ASourceFile: string; AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
begin
  LSourceStream := TFileStream.Create(ASourceFile, fmOpenRead or fmShareDenyWrite);
  try
    FHttpRequest := GetRequest(sHTTPMethodPost, AURL, LSourceStream, FAsynchronous);
    Result := DoExecute(FHttpRequest, AResponseContent, AHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Put(const AURL: string; const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

procedure TNetHTTPRequest.SetAccept(const Value: string);
begin
  CustomHeaders[sAccept] := Value
end;

procedure TNetHTTPRequest.SetAcceptCharSet(const Value: string);
begin
  CustomHeaders[sAcceptCharSet] := Value
end;

procedure TNetHTTPRequest.SetAcceptEncoding(const Value: string);
begin
  CustomHeaders[sAcceptEncoding] := Value
end;

procedure TNetHTTPRequest.SetAcceptLanguage(const Value: string);
begin
  CustomHeaders[sAcceptLanguage] := Value
end;

procedure TNetHTTPRequest.SetClient(const Value: TNetHTTPClient);
begin
  FClient := Value;
  if FClient <> nil then
  begin
    FConnectionTimeout := FClient.ConnectionTimeout;
    FResponseTimeout := FClient.ResponseTimeout;
  end;
end;

procedure TNetHTTPRequest.SetCustomHeaderValue(const AName, Value: string);
var
  I, Max: Integer;
begin
  I := 0;
  Max := Length(FCustomHeaders);
  while I < Max do
  begin
    if string.CompareText(FCustomHeaders[I].Name, AName) = 0 then
      Break;
    Inc(I);
  end;
  if I = Max then
  begin
    SetLength(FCustomHeaders, Max + 1);
    FCustomHeaders[I].Name := AName;
  end;
  FCustomHeaders[I].Value := Value;
end;

procedure TNetHTTPRequest.SetMethodString(const Value: string);
begin
  FMethodString := Value;
end;

procedure TNetHTTPRequest.SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
begin
  FOnNeedClientCertificate := Value;
end;

procedure TNetHTTPRequest.SetOnReceiveData(const Value: TReceiveDataEvent);
begin
  FOnReceiveData := Value;
end;

procedure TNetHTTPRequest.SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
begin
  FOnValidateServerCertificate := Value;
end;

procedure TNetHTTPRequest.SetURL(const Value: string);
begin
  FURL := Value;
end;

function TNetHTTPRequest.Trace(const AURL: string; const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodTrace, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

end.
